/*
 * This file shouldn't be posted as a patch. It is to be merged with
 * flif16_rangecoder.c.
 */

void ff_flif16_rac_enc_init(FLIF16RangeCoder *rc, PutByteContext *gb)
{
    rc->range          = FLIF16_RAC_MIN_RANGE;
    rc->low            = 0;
    rc->straddle_byte  = -1;
    rc->straddle_count = 0;
    rc->gb             = gb;
}

void ff_flif16_rac_enc_renorm(FLIF16RangeCoder *rc)
{
    int byte;
    while (rc->range <= FLIF16_RAC_MIN_RANGE) {
        byte = rc->low >> FLIF16_RAC_MIN_RANGE_BITS;
        if (rc->straddle_byte < 0) { // first generated byte
            rc->straddle_byte = byte;
        } else if (((rc->low + rc->range) >> 8) < FLIF16_RAC_MIN_RANGE) { // definitely no overflow
            bytestream2_put_byte(rc->straddle_byte);
            while (rc->straddle_count_count) {
                bytestream2_put_byte(0xFF);
                rc->straddle_count--;
            }
            rc->straddle_byte = byte;
        } else if ((rc->low >> 8) >= FLIF16_RAC_MIN_RANGE) { // definitely overflow
            bytestream2_put_byte(rc->straddle_byte + 1);
            while (rc->straddle_count) {
                bytestream2_put_byte(0x00);
                rc->straddle_count--;
            }
            rc->straddle_byte = byte & 0xFF;
        } else {
            rc->straddle_count++;
        }
        rc->low = (rc->low & (FLIF16_RAC_MIN_RANGE - 1)) << 8;
        rc->range <<= 8;
    }
}

static void ff_flif16_rac_enc_put(FLIF16RangeCoder *rc, uint32_t chance,
                              uint8_t bit)
{
    if (bit) {
        low += range - chance;
        range = chance;
    } else
        range -= chance;
}
static void ff_flif16_rac_enc_flush()
{
    rc->low += (FLIF16_RAC_MIN_RANGE - 1);
    for (int i = 0; i < 4; ++i) {
        rc->range = FLIF16_RAC_MIN_RANGE - 1;
        ff_flif16_rac_enc_renorm(rc);
    }
}

static void ff_flif16_rac_enc_write_bit(FLIF16RangeCoder *rc, uint8_t bit)
{
    ff_flif16_rac_enc_put(rc, range >> 1, bit);
}

static int ff_flif16_rac_enc_write_uni_int(FLIF16RangeCoder *rc, int min,
                                           int max, int val, int type)
{
    int med;
    if (!rc->active) {
        rc->active = 1;
        rc->min    = min;
        rc->max    = max;
    }

    if (rc->min) {
        rc->max -= rc->min;
        rc->val -= rc->min;
    }

    if (!rc->max) {
        rc->active = 0;
        return 1;
    }

    med = rc->max / 2;

    if (rc->val > med) {
        ff_flif16_rac_enc_write_bit(rc, 1)
        rc->min = med + 1;
    } else {
        ff_flif16_rac_enc_write_bit(rc, 0)
        rc->min = 0;
        rc->max = med;
    }
    return 0;
}

void inline ff_flif16_rac_enc_write_12bit_chance(FLIF16RangeCoder *rc,
                                                 uint64_t b12, uint8_t bit)
{
    uint32_t ret = (rc->range * b12 + 0x800) >> 12;
    return ff_flif16_rac_enc_put(rc, ret, bit);
}

// NearZero Integer Coder

static inline int ff_flif16_rac_nz_write_internal(FLIF16RangeCoder *rc,
                                                  FLIF16ChanceContext *ctx,
                                                  uint16_t type, uint8_t value)
{
    if(!ff_flif16_rac_enc_renorm(rc))
        return 0; // EAGAIN condition
    ff_flif16_rac_enc_write_chance(rc, ctx->data[type], value);
    ctx->data[type] = (!*target) ? rc->ct.zero_state[ctx->data[type]]
                                 : rc->ct.one_state[ctx->data[type]];
    return 1;
}

#define RAC_NZ_PUT(rc, ctx, chance, value)                                    \
    if (!ff_flif16_rac_nz_read_internal((rc), (ctx), (chance),                 \
                                        (uint8_t) (value))) {               \
        goto need_more_buffer;                                                   \
    }

int ff_flif16_rac_enc_write_nz_int(FLIF16RangeCoder *rc, int min, int max,
                                   int value)
{
    if (min == max)
        return 1;

    if (!rc->active) {
        rc->segment = 0;
        rc->amin    = 1;
        rc->active  = 1;
        rc->sign    = 0;
        rc->have    = 0;
    }

    switch (rc->segment) {
    case 0:
        RAC_NZ_PUT(rc, ctx, NZ_INT_ZERO, 0);
        rc->segment++;

        if (value == 0) { // value is zero
            return 1;
        }

        rc->sign = (value > 0 ? 1 : 0);

        if (max > 0 && min < 0) {
    case 1:
            RAC_NZ_PUT(rc, ctx, NZ_INT_SIGN, rc->sign);
        }
        rc->segment++;

        max = (sign ? 1 : -1);
        const int rc->e = ff_log2(abs(value));
        rc->amin = sign ? abs(min) : abs(max);
        rc->amax = sign ? abs(max) : abs(min);

        rc->emax = ff_log2(amax);
        rc->i = ff_log2(amin);

        while (rc->i < emax) {
            // if exponent >i is impossible, we are done
            if ((1 << (rc->i + 1)) > rc->amax)
                break;
    case 2:
            RAC_NZ_PUT(rc, ctx, NZ_INT_EXP((((rc->e) << 1) + rc->sign), rc->i == rc->e);
            if (rc->i == rc->e)
                break;
            rc->i++;
        }

        rc->have = (1 << rc->e);
        rc->left = rc->have - 1;
        rc->segment++;

        for (rc->pos = e; rc->pos > 0;) {
            int s->bit = 1;
            left ^= (1 << (--rc->pos));
            int s->minabs1 = rc->have | (1 << rc->pos);
            int s->maxabs0 = rc->have | rc->left;
            if (s->minabs1 > s->amax) { // 1-bit is impossible
                s->bit = 0;
            } else if (maxabs0 >= rc->amin) { // 0-bit and 1-bit are both possible
                s->bit = (abs(value) >> rc->pos) & 1;
                //coder.write(bit, BIT_MANT, pos);
    case 3:
                RAC_NZ_PUT(rc, ctx, NZ_INT_MANT(rc->pos), rc->bit);
            }
            rc->have |= (rc->bit << rc->pos);
        }
    }
}

int ff_flif16_rac_enc_write_gnz_int(FLIF16RangeCoder *rc,
                                    FLIF16ChanceContext *ctx,
                                    int min, int max, int value)
{
    int ret;
    if (min > 0) {
        ret = ff_flif16_rac_enc_write_nz_int(rc, ctx, 0, max - min, value - min);
    } else if (max < 0) {
        ret = ff_flif16_rac_enc_write_nz_int(rc, ctx, min - max, 0, value - max);
    } else
        ret = ff_flif16_rac_enc_write_nz_int(rc, ctx, min, max, value);

    return ret;
}

/*
template <typename BitChance, typename RAC>
void MetaPropertySymbolCoder<BitChance,RAC>::write_subtree(int pos, Ranges &subrange, const Tree &tree)
{
    const PropertyDecisionNode &n = tree[pos];
    int p = n.property;
    coder[0].write_int2(0,nb_properties,p+1);
    if (p != -1) {
        coder[1].write_int2(CONTEXT_TREE_MIN_COUNT, CONTEXT_TREE_MAX_COUNT, n.count);
//            printf("From properties 0..%i, split node at PROPERTY %i\n",nb_properties-1,p);
        int oldmin = subrange[p].first;
        int oldmax = subrange[p].second;
        assert(oldmin < oldmax);
        coder[2].write_int2(oldmin, oldmax-1, n.splitval);
//            e_printf( "Pos %i: prop %i splitval %i in [%i..%i]\n", pos, n.property, n.splitval, oldmin, oldmax-1);
        // > splitval
        subrange[p].first = n.splitval+1;
        write_subtree(n.childID, subrange, tree);

        // <= splitval
        subrange[p].first = oldmin;
        subrange[p].second = n.splitval;
        write_subtree(n.childID+1, subrange, tree);

        subrange[p].second = oldmax;
    }
}
template <typename BitChance, typename RAC>
void MetaPropertySymbolCoder<BitChance,RAC>::write_tree(const Tree &tree)
{
    //fprintf(stdout,"Saving tree with %lu nodes.\n",tree.size());
    Ranges rootrange(range);
    write_subtree(0, rootrange, tree);
}
*/

static inline int ff_flif16_rac_enc_process(FLIF16RangeCoder *rc,
                                            void *ctx, int val1, int val2,
                                            int value, int type)
{
    int flag = 0;
    while (!flag) {
        if (!ff_flif16_rac_enc_renorm(rc)) {
            return 0; // EAGAIN condition
        }

        switch (type) {
        case FLIF16_RAC_BIT:
            flag = ff_flif16_rac_enc_write_bit(rc, (uint8_t) value);
            break;

        case FLIF16_RAC_UNI_INT8:
        case FLIF16_RAC_UNI_INT16:
        case FLIF16_RAC_UNI_INT32:
            flag = ff_flif16_rac_enc_write_uni_int(rc, val1, val2, value, type);
            break;

        case FLIF16_RAC_CHANCE:
            flag = ff_flif16_rac_enc_write_chance(rc, val1, (uint8_t) value);
            break;

        case FLIF16_RAC_NZ_INT:
            flag = ff_flif16_rac_enc_write_nz_int(rc, (FLIF16ChanceContext *) ctx,
                                                  val1, val2, value);
            break;

        case FLIF16_RAC_GNZ_INT:
            flag = ff_flif16_rac_enc_write_gnz_int(rc, (FLIF16ChanceContext *) ctx,
                                                   val1, val2, value);
            break;
/*
#ifdef MULTISCALE_CHANCES_ENABLED
        case FLIF16_RAC_NZ_MULTISCALE_INT:
            flag = ff_flif16_rac_read_nz_multiscale_int(rc, (FLIF16MultiscaleChanceContext *) ctx,
                                                        val1, val2, (int *) target);
            break;

        case FLIF16_RAC_GNZ_MULTISCALE_INT:
            flag = ff_flif16_rac_read_gnz_multiscale_int(rc, (FLIF16MultiscaleChanceContext *) ctx,
                                                         val1, val2, (int *) target);
            break;
#endif
*/
        }
    }
    return 1;
}

#define RAC_PUT(rc, ctx, val1, val2, value, type) \
    if (!ff_flif16_rac_enc_process((rc), (ctx), (val1), (val2), (value), (type))) {\
        goto need_more_data;\
    }

#define MANIAC_PUT(rc, m, prop, channel, min, max, value) \
    if (!ff_flif16_maniac_write_int((rc), (m), (prop), (channel), (min), (max), (value))) {\
        goto need_more_data;\
    }
