/*
 * This file shouldn't be posted as a patch. It is to be merged with
 * flif16_rangecoder.c.
 */

void ff_flif16_rac_enc_init(FLIF16RangeCoder *rc, PutByteContext *gb)
{
    rc->range          = FLIF16_RAC_MIN_RANGE;
    rc->low            = 0;
    rc->straddle_byte  = -1;
    rc->straddle_count = 0;
    rc->gb             = gb;
}

void ff_flif16_rac_enc_renorm(FLIF16RangeCoder *rc)
{
    int byte;
    while (rc->range <= FLIF16_RAC_MIN_RANGE) {
        byte = rc->low >> FLIF16_RAC_MIN_RANGE_BITS;
        if (rc->straddle_byte < 0) { // first generated byte
            rc->straddle_byte = byte;
        } else if (((rc->low + rc->range) >> 8) < FLIF16_RAC_MIN_RANGE) { // definitely no overflow
            bytestream2_put_byte(rc->straddle_byte);
            while (rc->straddle_count_count) {
                bytestream2_put_byte(0xFF);
                rc->straddle_count--;
            }
            rc->straddle_byte = byte;
        } else if ((rc->low >> 8) >= FLIF16_RAC_MIN_RANGE) { // definitely overflow
            bytestream2_put_byte(rc->straddle_byte + 1);
            while (rc->straddle_count) {
                bytestream2_put_byte(0x00);
                rc->straddle_count--;
            }
            rc->straddle_byte = byte & 0xFF;
        } else {
            rc->straddle_count++;
        }
        rc->low = (rc->low & (FLIF16_RAC_MIN_RANGE - 1)) << 8;
        rc->range <<= 8;
    }
}

static void ff_flif16_rac_enc_put(FLIF16RangeCoder *rc, uint32_t chance,
                              uint8_t bit)
{
    if (bit) {
        low += range - chance;
        range = chance;
    } else
        range -= chance;
}
static void ff_flif16_rac_enc_flush()
{
    rc->low += (FLIF16_RAC_MIN_RANGE - 1);
    for (int i = 0; i < 4; ++i) {
        rc->range = FLIF16_RAC_MIN_RANGE - 1;
        ff_flif16_rac_enc_renorm(rc);
    }
}

static void ff_flif16_rac_enc_write_bit(FLIF16RangeCoder *rc, uint8_t bit)
{
    ff_flif16_rac_enc_put(rc, range >> 1, bit);
}

static int ff_flif16_rac_enc_write_uni_int(int min, int max, int val)
{
    int med;
    if (!rc->active) {
        rc->active = 1;
        rc->min    = 0;
        rc->max    = 1;
    }

    if (rc->min) {
        rc->max -= rc->min;
        rc->val -= rc->min;
    }

    if (!rc->max)
        return 1;

    med = rc->max / 2;

    if (rc->val > med) {
        ff_flif16_rac_enc_write_bit(rc, 1)
        rc->min = med + 1;
    } else {
        ff_flif16_rac_enc_write_bit(rc, 0)
        rc->min = 0;
        rc->max = med;
    }
    return 0;
}

#define RAC_PUT(rc, ctx, val1, val2, in)

int ff_flif16_rac_enc_write_nz_int(SymbolCoder& coder, int min, int max, int value)
{
    // avoid doing anything if the value is already known
    if (min == max) return;

    if (value == 0) { // value is zero
        coder.write(true, BIT_ZERO);
        return;
    }

    assert(min <= 0 && max >= 0); // should always be the case, because guess should always be in valid range

    // only output zero bit if value could also have been zero
    //if (max >= 0 && min <= 0)
    coder.write(false,BIT_ZERO);
    int sign = (value > 0 ? 1 : 0);
    if (max > 0 && min < 0) {
        // only output sign bit if value can be both pos and neg
        coder.write(sign,BIT_SIGN);
    }
    if (sign) min = 1;
    if (!sign) max = -1;
    const int a = abs(value);
    const int e = maniac::util::ilog2(a);
    int amin = sign ? abs(min) : abs(max);
    int amax = sign ? abs(max) : abs(min);

    int emax = maniac::util::ilog2(amax);
    int i = maniac::util::ilog2(amin);

    while (i < emax) {
        // if exponent >i is impossible, we are done
        if ((1 << (i+1)) > amax) break;
        // if exponent i is possible, output the exponent bit
        coder.write(i==e, BIT_EXP, (i<<1) + sign);
        if (i==e) break;
        i++;
    }
//  e_printf("exp=%i\n",e);
    int have = (1 << e);
    int left = have-1;
    for (int pos = e; pos>0;) {
        int bit = 1;
        left ^= (1 << (--pos));
        int minabs1 = have | (1<<pos);
        // int maxabs1 = have | left | (1<<pos);
        // int minabs0 = have;
        int maxabs0 = have | left;
        if (minabs1 > amax) { // 1-bit is impossible
            bit = 0;
        } else if (maxabs0 >= amin) { // 0-bit and 1-bit are both possible
            bit = (a >> pos) & 1;
            coder.write(bit, BIT_MANT, pos);
        }
        have |= (bit << pos);
    }
}

int ff_flif16_rac_read_nz_int(FLIF16RangeCoder *rc,
                              FLIF16ChanceContext *ctx,
                              int min, int max, int *target)
{
    uint8_t temp = 0;
    if (min == max) {
        *target = min;
        rc->active = 0;
        return 1;
    }

    if (!rc->active) {
        rc->segment = 0;
        rc->amin    = 1;
        rc->active  = 1;
        rc->sign    = 0;
        rc->have    = 0;
    }

    switch (rc->segment) {
    case 0:
        RAC_NZ_GET(rc, ctx, NZ_INT_ZERO, &(temp));
        if (temp) {
            *target = 0;
            rc->active = 0;
            return 1;
        }
        rc->segment++;

    case 1:
        if (min < 0) {
            if (max > 0) {
                RAC_NZ_GET(rc, ctx, NZ_INT_SIGN, &(rc->sign));
            } else {
                rc->sign = 0;
            }
        } else {
            rc->sign = 1;
        }
        rc->amax = (rc->sign ? max : -min);
        rc->emax = ff_log2(rc->amax);
        rc->e    = ff_log2(rc->amin);
        rc->segment++;

    case 2:
        for (; (rc->e) < (rc->emax); (rc->e++)) {
            RAC_NZ_GET(rc, ctx, NZ_INT_EXP((((rc->e) << 1) + rc->sign)),
                       &(temp));
            if (temp)
                break;
            temp = 0;
        }
        rc->have = (1 << (rc->e));
        rc->left = rc->have - 1;
        rc->pos  = rc->e;
        rc->segment++;

        while (rc->pos > 0) {
            (rc->pos)--;
            rc->left >>= 1;
            rc->minabs1 = (rc->have) | (1 << (rc->pos));
            rc->maxabs0 = (rc->have) | (rc->left);

            if ((rc->minabs1) > (rc->amax)) {
                continue;
            } else if ((rc->maxabs0) >= (rc->amin)) {
    case 3:
                RAC_NZ_GET(rc, ctx, NZ_INT_MANT(rc->pos), &temp);
                if (temp)
                    rc->have = rc->minabs1;
                temp = 0;
            } else
                rc->have = rc->minabs1;
        }
    }

    *target = ((rc->sign) ? (rc->have) : -(rc->have));
    rc->active = 0;
    return 1;

    need_more_data:
    return 0;
}
