/*
 * This file shouldn't be posted as a patch. It is to be merged with
 * flif16_rangecoder.c.
 */

#include "flif16_rangecoder_enc.h"
#define PRINT_LINE printf("At: %s, %s %d\n", __func__, __FILE__, __LINE__);

/**
 * Initializes the range encoder.
 */
void ff_flif16_rac_enc_init(FLIF16RangeCoder *rc, PutByteContext *pb)
{
    rc->range          = FLIF16_RAC_MAX_RANGE;
    rc->low            = 0;
    rc->straddle_byte  = -1;
    rc->straddle_count = 0;
    rc->bytestream     = pb;
    printf("range = %d low = %d sb = %d sc = %d\n",
           rc->range, rc->low, rc->straddle_byte, rc->straddle_count);
}

int ff_flif16_rac_enc_renorm(FLIF16RangeCoder *rc)
{
    int byte;
    while (rc->range <= FLIF16_RAC_MIN_RANGE) {
        printf("init range = %d low = %d sb = %d sc = %d\n",
           rc->range, rc->low, rc->straddle_byte, rc->straddle_count);
        byte = rc->low >> FLIF16_RAC_MIN_RANGE_BITS;
        if (!bytestream2_get_bytes_left_p(rc->bytestream))
            return 0;
        if (rc->straddle_byte < 0) { // first generated byte
            rc->straddle_byte = byte;
        } else if (((rc->low + rc->range) >> 8) < FLIF16_RAC_MIN_RANGE) { // definitely no overflow
            bytestream2_put_byte(rc->bytestream, rc->straddle_byte);
            while (rc->straddle_count) {
                bytestream2_put_byte(rc->bytestream, 0xFF);
                rc->straddle_count--;
            }
            rc->straddle_byte = byte;
        } else if ((rc->low >> 8) >= FLIF16_RAC_MIN_RANGE) { // definitely overflow
            bytestream2_put_byte(rc->bytestream, rc->straddle_byte + 1);
            while (rc->straddle_count) {
                bytestream2_put_byte(rc->bytestream, 0x00);
                rc->straddle_count--;
            }
            rc->straddle_byte = byte & 0xFF;
        } else {
            rc->straddle_count++;
        }
        rc->low = (rc->low & (FLIF16_RAC_MIN_RANGE - 1)) << 8;
        rc->range <<= 8;
    }

    return 1;
}

int ff_flif16_rac_enc_flush(FLIF16RangeCoder *rc)
{
    rc->low += FLIF16_RAC_MIN_RANGE - 1;

    rc->segment = 0;
    switch (rc->segment) {
    default:
        rc->segment = 1;
        for (int i = 0; i < 4; ++i) {
            rc->range = FLIF16_RAC_MIN_RANGE - 1;
    case 1:
            if (!ff_flif16_rac_enc_renorm(rc))
                return 0;
        }
    }

    rc->segment = 0;
    return 1;
}

int ff_flif16_rac_enc_put(FLIF16RangeCoder *rc, uint32_t chance,
                          uint8_t bit)
{
    if (bit) {
        rc->low += rc->range - chance;
        rc->range = chance;
    } else
        rc->range -= chance;

    return 1;
}

int ff_flif16_rac_enc_write_bit(FLIF16RangeCoder *rc, uint8_t bit)
{
    ff_flif16_rac_enc_put(rc, rc->range >> 1, bit);
    return 1;
}

int ff_flif16_rac_enc_write_uni_int(FLIF16RangeCoder *rc, int min,
                                    int max, int val, int type)
{
    int med;

    if (!rc->active) {
        rc->active = 1;
        rc->min    = min;
        rc->max    = max;
    }

    if (rc->min) {
        rc->max -= rc->min;
        rc->val -= rc->min;
    }

    if (!rc->max) {
        rc->active = 0;
        return 1;
    }

    med = rc->max / 2;

    if (rc->val > med) {
        ff_flif16_rac_enc_write_bit(rc, 1);
        rc->min = med + 1;
    } else {
        ff_flif16_rac_enc_write_bit(rc, 0);
        rc->min = 0;
        rc->max = med;
    }
    return 0;
}

int ff_flif16_rac_enc_write_chance(FLIF16RangeCoder *rc,
                                   uint64_t b12, uint8_t bit)
{
    uint32_t ret = (rc->range * b12 + 0x800) >> 12;
    return ff_flif16_rac_enc_put(rc, ret, bit);
}

// NearZero Integer Coder

static inline int ff_flif16_rac_enc_nz_write_internal(FLIF16RangeCoder *rc,
                                                      FLIF16ChanceContext *ctx,
                                                      uint16_t type, uint8_t value)
{
    if(!ff_flif16_rac_enc_renorm(rc))
        return 0; // EAGAIN condition
    ff_flif16_rac_enc_write_chance(rc, ctx->data[type], value);
    ctx->data[type] = (!value) ? rc->ct.zero_state[ctx->data[type]]
                               : rc->ct.one_state[ctx->data[type]];
    return 1;
}

#define RAC_NZ_PUT(rc, ctx, chance, value)                                     \
    if (!ff_flif16_rac_enc_nz_write_internal((rc), (ctx), (chance),            \
                                            (uint8_t) (value))) {              \
        goto need_more_buffer;                                                 \
    }

int ff_flif16_rac_enc_write_nz_int(FLIF16RangeCoder *rc, FLIF16ChanceContext *ctx,
                                   int min, int max, int value)
{
    if (min == max)
        return 1;

    if (!rc->active) {
        rc->segment = 0;
        rc->amin    = 1;
        rc->active  = 1;
        rc->sign    = 0;
        rc->have    = 0;
    }

    switch (rc->segment) {
    case 0:
        RAC_NZ_PUT(rc, ctx, NZ_INT_ZERO, 0);
        rc->segment++;

        if (value == 0) { // value is zero
            return 1;
        }

        rc->sign = (value > 0 ? 1 : 0);

        if (max > 0 && min < 0) {
    case 1:
            RAC_NZ_PUT(rc, ctx, NZ_INT_SIGN, rc->sign);
        }
        rc->segment++;

        max      = (rc->sign ? 1 : -1);
        rc->e    = ff_log2(abs(value));
        rc->amin = rc->sign ? abs(min) : abs(max);
        rc->amax = rc->sign ? abs(max) : abs(min);

        rc->emax = ff_log2(rc->amax);
        rc->i    = ff_log2(rc->amin);

        while (rc->i < rc->emax) {
            // if exponent >i is impossible, we are done
            if ((1 << (rc->i + 1)) > rc->amax)
                break;
    case 2:
            RAC_NZ_PUT(rc, ctx, NZ_INT_EXP(((rc->e << 1) + rc->sign)), rc->i == rc->e);
            if (rc->i == rc->e)
                break;
            rc->i++;
        }

        rc->have = (1 << rc->e);
        rc->left = rc->have - 1;
        rc->segment++;

        for (rc->pos = rc->e; rc->pos > 0;) {
            rc->bit = 1;
            rc->left ^= (1 << (--rc->pos));
            rc->minabs1 = rc->have | (1 << rc->pos);
            rc->maxabs0 = rc->have | rc->left;
            if (rc->minabs1 > rc->amax) { // 1-bit is impossible
                rc->bit = 0;
            } else if (rc->maxabs0 >= rc->amin) { // 0-bit and 1-bit are both possible
                rc->bit = (abs(value) >> rc->pos) & 1;
    case 3:
                RAC_NZ_PUT(rc, ctx, NZ_INT_MANT(rc->pos), rc->bit);
            }
            rc->have |= (rc->bit << rc->pos);
        }
    }

    return 1;

    need_more_buffer:
    return 0;
}

int ff_flif16_rac_enc_write_gnz_int(FLIF16RangeCoder *rc,
                                    FLIF16ChanceContext *ctx,
                                    int min, int max, int value)
{
    int ret;
    if (min > 0) {
        ret = ff_flif16_rac_enc_write_nz_int(rc, ctx, 0, max - min, value - min);
    } else if (max < 0) {
        ret = ff_flif16_rac_enc_write_nz_int(rc, ctx, min - max, 0, value - max);
    } else
        ret = ff_flif16_rac_enc_write_nz_int(rc, ctx, min, max, value);

    return ret;
}

/*
template <typename BitChance, typename RAC>
void MetaPropertySymbolCoder<BitChance,RAC>::write_subtree(int pos, Ranges &subrange, const Tree &tree)
{
    const PropertyDecisionNode &n = tree[pos];
    int p = n.property;
    coder[0].write_int2(0,nb_properties,p+1);
    if (p != -1) {
        coder[1].write_int2(CONTEXT_TREE_MIN_COUNT, CONTEXT_TREE_MAX_COUNT, n.count);
//            printf("From properties 0..%i, split node at PROPERTY %i\n",nb_properties-1,p);
        int oldmin = subrange[p].first;
        int oldmax = subrange[p].second;
        assert(oldmin < oldmax);
        coder[2].write_int2(oldmin, oldmax-1, n.splitval);
//            e_printf( "Pos %i: prop %i splitval %i in [%i..%i]\n", pos, n.property, n.splitval, oldmin, oldmax-1);
        // > splitval
        subrange[p].first = n.splitval+1;
        write_subtree(n.childID, subrange, tree);

        // <= splitval
        subrange[p].first = oldmin;
        subrange[p].second = n.splitval;
        write_subtree(n.childID+1, subrange, tree);

        subrange[p].second = oldmax;
    }
}
template <typename BitChance, typename RAC>
void MetaPropertySymbolCoder<BitChance,RAC>::write_tree(const Tree &tree)
{
    //fprintf(stdout,"Saving tree with %lu nodes.\n",tree.size());
    Ranges rootrange(range);
    write_subtree(0, rootrange, tree);
}
*/


